.TH "/devel/graphdata/graphDataLib/src/impl/arrayops.c" 3 "Graph Data Shared Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/devel/graphdata/graphDataLib/src/impl/arrayops.c
.SH SYNOPSIS
.br
.PP
\fC#include <impl/arraygraph\&.h>\fP
.br
\fC#include <impl/arrayops\&.h>\fP
.br
\fC#include <util/graphcomp\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "size_t \fBarrayNodeCount\fP (struct \fBgraph_t\fP *g)"
.br
.RI "Implementation for getting the node count;\&. "
.ti -1c
.RI "size_t \fBarrayEdgeCount\fP (struct \fBgraph_t\fP *g)"
.br
.RI "Implementation to extract count of edges\&. "
.ti -1c
.RI "struct \fBnode_t\fP * \fBarrayGetNode\fP (const size_t *nodeid, const struct \fBgraph_t\fP *g)"
.br
.RI "Implementation to retrieve a node structure reference\&. "
.ti -1c
.RI "struct \fBedge_t\fP * \fBarrayGetEdge\fP (const size_t *u, const size_t *v, const struct \fBgraph_t\fP *g)"
.br
.RI "Implementation to retrieve a edge structure reference\&. "
.ti -1c
.RI "struct \fBnode_t\fP * \fBarrayGetNeighbors\fP (const size_t *nodeid, const struct \fBgraph_t\fP *g)"
.br
.RI "Implementation to retrieve linked-list of nodes that are currently defined as neighbors to the given node\&. "
.ti -1c
.RI "struct \fBedge_t\fP * \fBarrayGetEdges\fP (const size_t *nodeid, const struct \fBgraph_t\fP *g)"
.br
.RI "Implementation to retrieve linked-list of edges from a given node\&. Returned linked-list is distinct from the graph structure, and consumers must use free() when finished\&. "
.ti -1c
.RI "int \fBarrayGetCapacity\fP (const size_t *uid, const size_t *vid, double *cap, const struct \fBgraph_t\fP *g)"
.br
.RI "Function pointer to retrieve the current capacity value for a given edge\&. "
.ti -1c
.RI "int \fBarrayGetFlow\fP (const size_t *uid, const size_t *vid, double *flow, const struct \fBgraph_t\fP *g)"
.br
.RI "Function pointer to retrieve the current flow value for a given edge\&. "
.ti -1c
.RI "int \fBarrayAddNode\fP (const size_t *nodeid, struct \fBgraph_t\fP *g)"
.br
.RI "Implementation to add a node to a given graph\&. NOOP implementation for array-based graphs--the node counts are fixed at creation\&. "
.ti -1c
.RI "int \fBarrayRemoveNode\fP (const size_t *nodeid, struct \fBgraph_t\fP *g)"
.br
.RI "Remove a node from the graph\&. "
.ti -1c
.RI "int \fBarrayAddEdge\fP (const size_t *uid, const size_t *vid, double *cap, struct \fBgraph_t\fP *g)"
.br
.RI "Implementation to add an edge to a given graph\&. "
.ti -1c
.RI "int \fBarrayRemoveEdge\fP (const size_t *uid, const size_t *vid, struct \fBgraph_t\fP *g)"
.br
.RI "Function pointer to remove an edge from the given graph\&. "
.ti -1c
.RI "int \fBarraySetCapacity\fP (const size_t *uid, const size_t *vid, const double *cap, struct \fBgraph_t\fP *g)"
.br
.RI "Implementation to set the capacity (cost, weight, etc\&.) of an edge in the given graph\&. "
.ti -1c
.RI "int \fBarrayAddCapacity\fP (const size_t *uid, const size_t *vid, const double *cap, struct \fBgraph_t\fP *g)"
.br
.RI "Function to add (adjust) the capacity for an edge by a given amount\&. "
.ti -1c
.RI "int \fBarraySetFlow\fP (const size_t *uid, const size_t *vid, const double *flow, struct \fBgraph_t\fP *g)"
.br
.RI "Function to set the flow value for an edge (amount of capacity currently 'used') "
.ti -1c
.RI "int \fBarrayAddFlow\fP (const size_t *uid, const size_t *vid, const double *flow, struct \fBgraph_t\fP *g)"
.br
.RI "Function to adjust the flow value of a given edge\&. "
.ti -1c
.RI "int \fBarrayResetGraph\fP (struct \fBgraph_t\fP *g, void *args, void(*callback)(void))"
.br
.RI "Implementation to 'reset' the graph according to the given argument pointer\&. "
.ti -1c
.RI "int \fBfreeGraphArray\fP (size_t arraylen, void **arrptr)"
.br
.RI "Utility method to free up an array\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "int arrayAddCapacity (const size_t * uid, const size_t * vid, const double * cap, struct \fBgraph_t\fP * g)"

.PP
Function to add (adjust) the capacity for an edge by a given amount\&. For implementations that require it, this function allows the altering of a specified edge capacity by the given amount\&.
.PP
\fBParameters\fP
.RS 4
\fIuid\fP Identifier of the edge start 
.br
\fIvid\fP Identifier of the edge end\&. 
.br
\fIcap\fP Value to adjust the capacity 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
0 if there was an error (edge not found, for example); 1 of capacity was successfully adjusted 
.RE
.PP

.SS "int arrayAddEdge (const size_t * uid, const size_t * vid, double * cap, struct \fBgraph_t\fP * g)"

.PP
Implementation to add an edge to a given graph\&. Implementation to add an edge to a given graph\&. Not all implementations may use this (for example, fixed-size ARRAY implementations representing a set domain of nodes and relationships)\&.
.PP
Adds a connecting-edge referece (if not already in place, and the degree of the graph allows it (there are unfilled spots available for the given uid)\&.
.PP
\fBParameters\fP
.RS 4
\fIuid\fP identifer for start of edge 
.br
\fIvid\fP identifier for end of edge 
.br
\fIcap\fP capacity value to be assigned 
.br
\fIg\fP graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
0 if there was an error; 1 if the edge was successfully added\&. 
.RE
.PP

.SS "int arrayAddFlow (const size_t * uid, const size_t * vid, const double * flow, struct \fBgraph_t\fP * g)"

.PP
Function to adjust the flow value of a given edge\&. Add the flow value to the flow tracking of the given graph\&.
.PP
\fBParameters\fP
.RS 4
\fIuid\fP Identifier of the edge start 
.br
\fIvid\fP Identifier of the edge end\&. 
.br
\fIflow\fP The value to be added to adjust the flow value\&. 
.br
\fIg\fP The graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
0 if there was an error (such as the edge not found); otherwise, 1 if the flow value was successfully adjusted\&. 
.RE
.PP

.SS "int arrayAddNode (const size_t * nodeid, struct \fBgraph_t\fP * g)"

.PP
Implementation to add a node to a given graph\&. NOOP implementation for array-based graphs--the node counts are fixed at creation\&. Implementation to add a node to a given graph\&. Not all implementations may use this (for example, fixed-size graphs such as spatial ARRAY implementations)\&.
.PP
\fBParameters\fP
.RS 4
\fInodeid\fP Node identifier to be added 
.br
\fIg\fP Graph structure to add the node 
.RE
.PP
\fBReturns\fP
.RS 4
0 if there was an error, 1 if the node was successfully added 
.RE
.PP

.SS "size_t arrayEdgeCount (struct \fBgraph_t\fP * g)"

.PP
Implementation to extract count of edges\&. 
.PP
\fBParameters\fP
.RS 4
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
Count of edges, if graph is not null; otherwise, return 0 
.RE
.PP

.SS "int arrayGetCapacity (const size_t * uid, const size_t * vid, double * cap, const struct \fBgraph_t\fP * g)"

.PP
Function pointer to retrieve the current capacity value for a given edge\&. For implementations that support this, the capacity value will be written to the *cap parameter\&.
.PP
\fBParameters\fP
.RS 4
\fIuid\fP Edge start identifier 
.br
\fIvid\fP Edge end identifier 
.br
\fIcap\fP Capacity value pointer to store the value 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
0 if there was a problem retrieving the value (such as the edge not existing); otherwise, 1 for a successful retrieval 
.RE
.PP

.SS "struct \fBedge_t\fP * arrayGetEdge (const size_t * u, const size_t * v, const struct \fBgraph_t\fP * g)"

.PP
Implementation to retrieve a edge structure reference\&. Implementation-specific on whether this structure is part of the original graph (LINK-based implementations) or must use free() when usage is finished (ARRAY-based)\&. 
.PP
\fBParameters\fP
.RS 4
\fIu\fP nodeid of the starting edge\&. 
.br
\fIv\fP nodeid of the ending edge\&. 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the edge structure, if found; otherwise, pointer to NULL\&. 
.RE
.PP

.SS "struct \fBedge_t\fP * arrayGetEdges (const size_t * nodeid, const struct \fBgraph_t\fP * g)"

.PP
Implementation to retrieve linked-list of edges from a given node\&. Returned linked-list is distinct from the graph structure, and consumers must use free() when finished\&. 
.PP
\fBParameters\fP
.RS 4
\fInodeid\fP Identifier of the node in question 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
linked-list of edges starting from the given node, if found; otherwise, pointer to NULL\&. 
.RE
.PP

.SS "int arrayGetFlow (const size_t * uid, const size_t * vid, double * flow, const struct \fBgraph_t\fP * g)"

.PP
Function pointer to retrieve the current flow value for a given edge\&. For implementations that support this, the flow value will be written to the *flow parameter\&.
.PP
\fBParameters\fP
.RS 4
\fIuid\fP Edge start identifier 
.br
\fIvid\fP Edge end identifier 
.br
\fIflow\fP Flow value pointer to store the result 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
0 if there was a problem retrieving the value (such as the edge not existing); otherwise, 1 for a successful retrieval 
.RE
.PP

.SS "struct \fBnode_t\fP * arrayGetNeighbors (const size_t * nodeid, const struct \fBgraph_t\fP * g)"

.PP
Implementation to retrieve linked-list of nodes that are currently defined as neighbors to the given node\&. Returned linked-list is distinct from the graph structure, and consumers must use free() when finished\&. 
.PP
\fBParameters\fP
.RS 4
\fInodeid\fP Identifier of the node in question 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
linked-list of node references, starting with the given node, if found; otherwise, pointer to NULL\&. 
.RE
.PP

.SS "struct \fBnode_t\fP * arrayGetNode (const size_t * nodeid, const struct \fBgraph_t\fP * g)"

.PP
Implementation to retrieve a node structure reference\&. If the struct returned is not NULL, the consumer is responsible for calling free() on the memory\&.
.PP
\fBParameters\fP
.RS 4
\fInodeid\fP Identifier of the node to be retrieved 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the node structure, if found; otherwise, pointer to NULL 
.RE
.PP

.SS "size_t arrayNodeCount (struct \fBgraph_t\fP * g)"

.PP
Implementation for getting the node count;\&. 
.PP
\fBParameters\fP
.RS 4
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
Count of nodes, if graph is not null; otherwise, return 0 
.RE
.PP

.SS "int arrayRemoveEdge (const size_t * uid, const size_t * vid, struct \fBgraph_t\fP * g)"

.PP
Function pointer to remove an edge from the given graph\&. Remove references for an edge within the structure\&.
.PP
\fBParameters\fP
.RS 4
\fIuid\fP Identifier for the edge start 
.br
\fIvid\fP Identifier for the edge end\&. 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
0 if there was an error (e\&.g\&. the edge was not found); otherwise, 1 if the edge was removed\&. 
.RE
.PP

.SS "int arrayRemoveNode (const size_t * nodeid, struct \fBgraph_t\fP * g)"

.PP
Remove a node from the graph\&. NOOP implementation\&. ARRAY-based graphs are defined at initialization and do not allow removing nodes\&.
.PP
\fBParameters\fP
.RS 4
\fInodeid\fP Node id to be added\&. 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
0 if there was an error (node already exists or outside the bounds of the implementation); otherwise, 1 if successful\&. 
.RE
.PP

.SS "int arrayResetGraph (struct \fBgraph_t\fP * g, void * args, void(*)(void) callback)"

.PP
Implementation to 'reset' the graph according to the given argument pointer\&. For this implementation, the args value is ignored and the edge values are set to 0\&.0 again\&.
.PP
\fBParameters\fP
.RS 4
\fIg\fP Graph structure to be zeroed or modified according to reset logic 
.br
\fIargs\fP Arguments to be((\fBarraydata_t\fP *)g->metaImpl used in the reset process, if necessary 
.br
\fIcallback\fP Callback to be executed when graph has been reset\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if there was an error during the reset; 1 if the reset completed; 
.RE
.PP

.SS "int arraySetCapacity (const size_t * uid, const size_t * vid, const double * cap, struct \fBgraph_t\fP * g)"

.PP
Implementation to set the capacity (cost, weight, etc\&.) of an edge in the given graph\&. 
.PP
\fBParameters\fP
.RS 4
\fIuid\fP identifier of the edge start 
.br
\fIvid\fP identifier of the edge ending\&. 
.br
\fIcap\fP capacity value to be set 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
0 if there was an error; 1 if the capacity was successfully set 
.RE
.PP

.SS "int arraySetFlow (const size_t * uid, const size_t * vid, const double * flow, struct \fBgraph_t\fP * g)"

.PP
Function to set the flow value for an edge (amount of capacity currently 'used') Set the flow value for the given edge\&.
.PP
\fBParameters\fP
.RS 4
\fIuid\fP Identifier of the edge start\&. 
.br
\fIvid\fP Identifier of the edge end\&. 
.br
\fIflow\fP Value to be set for the flow\&. 
.br
\fIg\fP Graph structure in question 
.RE
.PP
\fBReturns\fP
.RS 4
0 of there was an error (edge not found, for example); otherwise, 1 if the flow value as successfully set\&. 
.RE
.PP

.SS "int freeGraphArray (size_t arraylen, void ** arrptr)"

.PP
Utility method to free up an array\&. Deallocates all unerlying arrays and the containing array\&. 
.PP
\fBParameters\fP
.RS 4
\fIarraylen\fP Number of elements in the array 
.br
\fIarr\fP 2D array to be cleared 
.RE
.PP
\fBReturns\fP
.RS 4
1 if successful; 0 if error\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Graph Data Shared Library from the source code\&.
